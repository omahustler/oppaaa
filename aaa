
import asyncio
import os
from datetime import datetime
import nest_asyncio
import openpyxl
from telegram import Update, ReplyKeyboardMarkup, ReplyKeyboardRemove
from telegram.ext import (
    ApplicationBuilder,
    CommandHandler,
    MessageHandler,
    ContextTypes,
    ConversationHandler,
    filters,
)

nest_asyncio.apply()

BOT_TOKEN = "7507868545:AAFKMbUZAhYPdcLXn4udlFqd5JOgN0A-51k"

employees = {
    "Омар": 491787588,
    "Джони": 1182121258,
    "Дамирка": 1273714356,
    "Моля": 667064261,
    "Акеж": 926330557,
    "Тоша": 722966090,
    "Арука": 1782361981
    # Add other employees here
}

FILE_NAME = "porucheniya.xlsx"
if os.path.exists(FILE_NAME):
    wb = openpyxl.load_workbook(FILE_NAME)
    ws = wb.active
else:
    wb = openpyxl.Workbook()
    ws = wb.active
    ws.append(["Поручение", "Срок", "Ответственный"])

ASK_TASK, ASK_DATE, ASK_PERSON, ASK_DELETE = range(4)

menu_keyboard = ReplyKeyboardMarkup(
    [
        ["Новое поручение"],
        ["Показать все поручения", "Мои поручения"],
        ["Удалить поручение"]
    ],
    resize_keyboard=True
)


async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("Выберите действие:", reply_markup=menu_keyboard)


async def handle_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    choice = update.message.text

    if choice == "Новое поручение":
        await update.message.reply_text("Напиши поручение:", reply_markup=ReplyKeyboardRemove())
        return ASK_TASK

    elif choice == "Показать все поручения":
        rows = list(ws.iter_rows(min_row=2, values_only=True))
        if not rows:
            await update.message.reply_text("Поручений нет.", reply_markup=menu_keyboard)
        else:
            text = "\n\n".join([f"{i+1}. {r[0]}\nСрок: {r[1]}\nОтветственный: {r[2]}" for i, r in enumerate(rows)])
            await update.message.reply_text(text, reply_markup=menu_keyboard)
        return ConversationHandler.END

    elif choice == "Мои поручения":
        user_id = update.message.from_user.id
        name = next((n for n, uid in employees.items() if uid == user_id), None)

        if not name:
            await update.message.reply_text("Вы не зарегистрированы как сотрудник.", reply_markup=menu_keyboard)
            return ConversationHandler.END

        rows = list(ws.iter_rows(min_row=2, values_only=True))
        my_tasks = [(i+1, r[0], r[1]) for i, r in enumerate(rows) if r[2] == name]

        if not my_tasks:
            await update.message.reply_text("У вас нет активных поручений.", reply_markup=menu_keyboard)
        else:
            text = "\n\n".join([f"{i}. {task}\nСрок: {date}" for i, task, date in my_tasks])
            await update.message.reply_text(text, reply_markup=menu_keyboard)
        return ConversationHandler.END

    elif choice == "Удалить поручение":
        rows = list(ws.iter_rows(min_row=2, values_only=True))
        if not rows:
            await update.message.reply_text("Удалять нечего.", reply_markup=menu_keyboard)
            return ConversationHandler.END

        text = "\n".join([f"{i+1}. {r[0]} (до {r[1]}) — {r[2]}" for i, r in enumerate(rows)])
        await update.message.reply_text("Выберите номер поручения для удаления:\n" + text)
        return ASK_DELETE

    else:
        await update.message.reply_text("Неверный выбор.", reply_markup=menu_keyboard)
        return ConversationHandler.END


async def handle_task(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data['task'] = update.message.text
    await update.message.reply_text("Когда срок выполнения? (ДД.ММ.ГГГГ)")
    return ASK_DATE


async def handle_date(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        datetime.strptime(update.message.text, "%d.%m.%Y")
        context.user_data['date'] = update.message.text
    except ValueError:
        await update.message.reply_text("Неверный формат. Введите дату в виде ДД.ММ.ГГГГ.")
        return ASK_DATE

    keyboard = [[name] for name in employees.keys()]
    reply_markup = ReplyKeyboardMarkup(keyboard, one_time_keyboard=True, resize_keyboard=True)
    await update.message.reply_text("Кто ответственный?", reply_markup=reply_markup)
    return ASK_PERSON


async def handle_person(update: Update, context: ContextTypes.DEFAULT_TYPE):
    person = update.message.text
    task = context.user_data.get('task')
    date = context.user_data.get('date')

    if person not in employees:
        await update.message.reply_text("Сотрудник не найден. Выберите снова.")
        keyboard = [[name] for name in employees.keys()]
        reply_markup = ReplyKeyboardMarkup(keyboard, one_time_keyboard=True, resize_keyboard=True)
        await update.message.reply_text("Кто ответственный?", reply_markup=reply_markup)
        return ASK_PERSON

    ws.append([task, date, person])
    wb.save(FILE_NAME)

    try:
        await context.bot.send_message(
            chat_id=employees[person],
            text=f"Новое поручение:\n\"{task}\"\nСрок: {date}"
        )
    except Exception:
        await update.message.reply_text(f"Ошибка при отправке поручения {person}.")

    await update.message.reply_text("Поручение записано.", reply_markup=menu_keyboard)
    return ConversationHandler.END


async def handle_delete(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        idx = int(update.message.text)
        rows = list(ws.iter_rows(min_row=2, values_only=True))
        if not (1 <= idx <= len(rows)):
            raise ValueError
    except Exception:
        await update.message.reply_text("Неверный номер. Повторите.")
        return ASK_DELETE

    ws.delete_rows(idx + 1)
    wb.save(FILE_NAME)

    await update.message.reply_text("Поручение удалено.", reply_markup=menu_keyboard)
    return ConversationHandler.END


async def daily_notifications(application):
    while True:
        now = datetime.now().strftime("%d.%m.%Y")
        wb_check = openpyxl.load_workbook(FILE_NAME)
        ws_check = wb_check.active
        user_tasks = {}

        for row in ws_check.iter_rows(min_row=2, values_only=True):
            task, date, person = row
            if date == now and person in employees:
                user_tasks.setdefault(person, []).append(task)

        for person, tasks in user_tasks.items():
            msg = "У тебя на сегодня следующие поручения:\n" + "\n".join(f"— {t}" for t in tasks)
            try:
                await application.bot.send_message(chat_id=employees[person], text=msg)
            except Exception:
                pass

        await asyncio.sleep(86400)


async def main():
    app = ApplicationBuilder().token(BOT_TOKEN).build()

    conv_handler = ConversationHandler(
        entry_points=[
            CommandHandler("start", start),
            MessageHandler(filters.Regex("^(Новое поручение|Показать все поручения|Удалить поручение|Мои поручения)$"), handle_menu)
        ],
        states={
            ASK_TASK: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_task)],
            ASK_DATE: [MessageHandler(filters.TEXT, handle_date)],
            ASK_PERSON: [MessageHandler(filters.TEXT, handle_person)],
            ASK_DELETE: [MessageHandler(filters.TEXT, handle_delete)],
        },
        fallbacks=[]
    )

    app.add_handler(conv_handler)

    async def post_startup(_: ContextTypes.DEFAULT_TYPE):
        asyncio.create_task(daily_notifications(app))

    app.post_init = post_startup

    print("Бот запущен...")
    await app.run_polling()


loop = asyncio.get_event_loop()
loop.run_until_complete(main())
